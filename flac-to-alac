#!/usr/bin/env python3

import argparse
import os
import sys
import subprocess
import shutil
from pathlib import Path
import urllib.request
import tempfile
from concurrent.futures import ProcessPoolExecutor, as_completed
import multiprocessing


VERSION = "0.2.0"
REPO_URL = "https://raw.githubusercontent.com/jezhou/flac-to-alac/main"


def update_tool():
    """Update flac-to-alac to the latest version."""
    print("Checking for updates...")

    try:
        # Find where the script is installed
        script_path = shutil.which('flac-to-alac')
        if not script_path:
            # If not in PATH, use the current file
            script_path = os.path.abspath(__file__)

        # Download the latest version
        with tempfile.NamedTemporaryFile(mode='w', delete=False) as tmp_file:
            response = urllib.request.urlopen(f"{REPO_URL}/flac-to-alac")
            content = response.read().decode('utf-8')
            tmp_file.write(content)
            tmp_path = tmp_file.name

        # Check if we need sudo for the installation directory and file
        install_dir = os.path.dirname(script_path)
        needs_sudo = (not os.access(install_dir, os.W_OK) or
                     not os.access(script_path, os.W_OK))

        # Replace the old script with the new one
        try:
            if needs_sudo:
                print(f"Installing update to {script_path} (requires sudo)...")
                subprocess.run(['sudo', 'cp', tmp_path, script_path], check=True)
                subprocess.run(['sudo', 'chmod', '755', script_path], check=True)
            else:
                shutil.copy2(tmp_path, script_path)
                os.chmod(script_path, 0o755)
        except PermissionError:
            print(f"Permission denied: Cannot write to {script_path}")
            print("Please run the update with sudo:")
            print(f"  sudo {script_path} --update")
            os.unlink(tmp_path)
            sys.exit(1)

        # Clean up
        os.unlink(tmp_path)

        print("Successfully updated flac-to-alac!")
        print("Run 'flac-to-alac --version' to see the new version.")

    except Exception as e:
        print(f"Error updating: {str(e)}")
        sys.exit(1)


def check_ffmpeg():
    """Check if ffmpeg is installed on the system."""
    if not shutil.which('ffmpeg'):
        print("Error: ffmpeg is not installed.")
        print("Please install ffmpeg to use this tool.")
        print("On macOS: brew install ffmpeg")
        print("On Ubuntu/Debian: sudo apt-get install ffmpeg")
        sys.exit(1)


def convert_file_worker(args):
    """Worker function for parallel processing."""
    input_path, output_path, format = args
    return convert_file(input_path, output_path, format), input_path, output_path


def convert_file(input_path, output_path, format='alac'):
    """Convert a single FLAC file to ALAC/AAC M4A format."""
    try:
        cmd = [
            'ffmpeg',
            '-i', str(input_path),
        ]

        if format == 'alac':
            # Lossless ALAC encoding
            cmd.extend(['-c:a', 'alac'])
        else:  # format == 'aac'
            # Lossy AAC encoding with high quality
            cmd.extend(['-c:a', 'aac', '-q:a', '1', '-movflags', '+faststart'])

        cmd.extend([
            '-c:v', 'copy',
            '-loglevel', 'error',
            '-y',  # Overwrite output files
            str(output_path)
        ])

        result = subprocess.run(cmd, capture_output=True, text=True)

        if result.returncode != 0:
            print(f"Error converting {input_path}: {result.stderr}")
            return False

        return True
    except Exception as e:
        print(f"Error converting {input_path}: {str(e)}")
        return False


def convert_single_file(file_path, format='alac'):
    """Convert a single FLAC file, placing output in the same directory."""
    input_path = Path(file_path)

    if not input_path.exists():
        print(f"Error: File '{file_path}' does not exist.")
        sys.exit(1)

    if input_path.suffix.lower() != '.flac':
        print(f"Error: File '{file_path}' is not a FLAC file.")
        sys.exit(1)

    output_path = input_path.with_suffix('.m4a')

    format_desc = "ALAC (lossless)" if format == 'alac' else "AAC (lossy)"
    print(f"Converting to {format_desc}: {input_path} -> {output_path}")

    if convert_file(input_path, output_path, format):
        print("Conversion completed successfully.")
    else:
        sys.exit(1)


def convert_directory(dir_path, output_dir=None, format='alac', workers=None):
    """Convert all FLAC files in a directory recursively."""
    input_dir = Path(dir_path)

    if not input_dir.exists():
        print(f"Error: Directory '{dir_path}' does not exist.")
        sys.exit(1)

    if not input_dir.is_dir():
        print(f"Error: '{dir_path}' is not a directory.")
        sys.exit(1)

    # Find all FLAC files
    flac_files = list(input_dir.rglob('*.flac')) + list(input_dir.rglob('*.FLAC'))

    if not flac_files:
        print(f"No FLAC files found in '{dir_path}'.")
        return

    format_desc = "ALAC (lossless)" if format == 'alac' else "AAC (lossy)"
    
    # Set default workers if not specified
    if workers is None:
        workers = min(8, multiprocessing.cpu_count())
    
    print(f"Found {len(flac_files)} FLAC file(s) to convert to {format_desc}.")
    if workers > 1:
        print(f"Using {workers} parallel workers.")

    # Determine output directory
    if output_dir:
        output_base = Path(output_dir)
        output_base.mkdir(parents=True, exist_ok=True)
    else:
        output_base = input_dir

    # Prepare conversion tasks
    conversion_tasks = []
    for flac_file in flac_files:
        # Calculate relative path and output path
        if output_dir:
            rel_path = flac_file.relative_to(input_dir)
            output_path = output_base / rel_path.with_suffix('.m4a')
            output_path.parent.mkdir(parents=True, exist_ok=True)
        else:
            output_path = flac_file.with_suffix('.m4a')
        
        conversion_tasks.append((flac_file, output_path, format))

    # Convert files (parallel or sequential)
    converted = 0
    failed = 0

    if workers == 1:
        # Sequential processing (original behavior)
        for flac_file, output_path, format in conversion_tasks:
            print(f"Converting: {flac_file} -> {output_path}")
            if convert_file(flac_file, output_path, format):
                converted += 1
            else:
                failed += 1
    else:
        # Parallel processing
        with ProcessPoolExecutor(max_workers=workers) as executor:
            # Submit all tasks
            future_to_task = {
                executor.submit(convert_file_worker, task): task 
                for task in conversion_tasks
            }
            
            # Process completed tasks
            for future in as_completed(future_to_task):
                task = future_to_task[future]
                flac_file, output_path, format = task
                
                try:
                    success, input_path, output_path = future.result()
                    if success:
                        converted += 1
                        print(f"✓ Completed: {input_path}")
                    else:
                        failed += 1
                        print(f"✗ Failed: {input_path}")
                except Exception as e:
                    failed += 1
                    print(f"✗ Error: {flac_file} - {str(e)}")

    print(f"\nConversion complete: {converted} succeeded, {failed} failed.")


def main():
    parser = argparse.ArgumentParser(
        prog='flac-to-alac',
        description='Convert FLAC audio files to ALAC/AAC M4A format using ffmpeg.',
        epilog='Examples:\n'
               '  flac-to-alac -f song.flac                        # Convert single file to AAC\n'
               '  flac-to-alac -f song.flac --format alac         # Convert to ALAC (lossless)\n'
               '  flac-to-alac -d ./music                         # Convert directory (parallel)\n'
               '  flac-to-alac -d ./music -j 4                   # Use 4 parallel workers\n'
               '  flac-to-alac -d ./music -o ./converted -j 1    # Sequential conversion',
        formatter_class=argparse.RawDescriptionHelpFormatter
    )

    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument(
        '-f', '--file',
        help='Convert a single FLAC file',
        metavar='FILE'
    )
    group.add_argument(
        '-d', '--directory',
        help='Convert all FLAC files in a directory recursively',
        metavar='DIR'
    )
    group.add_argument(
        '--update',
        action='store_true',
        help='Update flac-to-alac to the latest version'
    )
    group.add_argument(
        '--version',
        action='store_true',
        help='Show version information'
    )

    parser.add_argument(
        '-o', '--output',
        help='Output directory (only works with -d option)',
        metavar='DIR'
    )

    parser.add_argument(
        '-F', '--format',
        choices=['alac', 'aac'],
        default='aac',
        help='Output format: aac (lossy, default) or alac (lossless)',
        metavar='FORMAT'
    )
    
    parser.add_argument(
        '-j', '--workers',
        type=int,
        default=None,
        help='Number of parallel workers (default: auto-detect, 1 = sequential)',
        metavar='N'
    )

    args = parser.parse_args()

    # Handle version flag
    if args.version:
        print(f"flac-to-alac version {VERSION}")
        sys.exit(0)

    # Handle update flag
    if args.update:
        update_tool()
        sys.exit(0)

    # Check if ffmpeg is installed
    check_ffmpeg()

    # Validate -o option
    if args.output and not args.directory:
        parser.error("-o/--output option can only be used with -d/--directory option")

    # Process based on input type
    if args.file:
        convert_single_file(args.file, args.format)
    else:
        convert_directory(args.directory, args.output, args.format, args.workers)


if __name__ == '__main__':
    main()